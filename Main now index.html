<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tilt Game - TiffyAI</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: url('tilt.gif') no-repeat center center fixed;
        background-size: cover;
        font-family: 'Orbitron', sans-serif;
        color: white;
    }
    canvas {
        display: block;
    }
    #loadingScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 2rem;
        z-index: 100;
    }
    #accelerator {
        position: fixed;
        bottom: 30px;
        right: 30px;
        width: 90px;
        height: 90px;
        border-radius: 50%;
        background: rgba(0, 200, 255, 0.2);
        border: 2px solid rgba(0, 255, 255, 0.5);
        backdrop-filter: blur(10px);
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.9), inset 0 0 15px rgba(0, 200, 255, 0.7);
        animation: pulse 1.5s infinite;
        z-index: 2;
        color: white;
        font-family: Arial, sans-serif;
        font-size: 14px;
        text-align: center;
        line-height: 90px;
        user-select: none;
        cursor: pointer;
    }
    #accelerator.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        animation: none;
        box-shadow: none;
        background: rgba(100, 100, 100, 0.2);
        border: 2px solid rgba(100, 100, 100, 0.5);
    }
    @keyframes pulse {
        0% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), inset 0 0 10px rgba(0, 200, 255, 0.5); }
        50% { box-shadow: 0 0 25px rgba(0, 255, 255, 1), inset 0 0 20px rgba(0, 200, 255, 0.7); }
        100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), inset 0 0 10px rgba(0, 200, 255, 0.5); }
    }
    #scoreContainer {
        position: absolute;
        top: 15px;
        left: 20px;
        display: flex;
        align-items: center;
        color: #fff;
        text-shadow: 0 0 5px #000;
        font-family: Arial, sans-serif;
    }
    #score {
        font-size: 1.2rem;
    }
    #gameOverScreen {
        position: fixed;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.85);
        color: white;
        font-family: Arial, sans-serif;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 10;
    }
    #tryAgainBtn {
        padding: 10px 20px;
        font-size: 1.2rem;
        background: #00ffff;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        margin-top: 20px;
        color: #000;
    }
</style>
</head>
<body>

<div id="loadingScreen">Loading...</div>
<canvas id="gameCanvas"></canvas>
<div id="scoreContainer">
    <div id="score">Earnings: 0.00 TIFFY</div>
</div>
<div id="accelerator">POWER</div>

<div id="gameOverScreen">
    <h1>Game Over!</h1>
    <button id="tryAgainBtn">Try Again</button>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const ball = { x: canvas.width / 2, y: canvas.height / 2, r: 20, shimmerAngle: 0 };
const goal = { x: Math.random() * (canvas.width - 60) + 30, y: Math.random() * (canvas.height - 60) + 30, size: 50 };
let obstacles = [];
let particles = [];
let speed = { x: 0, y: 0 };
let boostFactor = 2;

let baseTiltSpeed = 10;
let speedIncreasePerCoin = 0.5;
let currentTiltSpeed = baseTiltSpeed;

const tiffyPerPoint = 0.02;
let scoreTiffy = parseFloat(localStorage.getItem('tetrusScore') || '0');
updateScoreDisplay();

let boostActive = false;
let isBoostReady = true;
const boostCooldownTime = 2000;

let goalImg = new Image();
goalImg.src = "TiffyAI-Token.png";

let bubbleSound = new Audio("Bubble.wav");
let breakSound = new Audio("break.wav");
let impactSound = new Audio("impact.mp3");
let gameOverSound = new Audio("game-over.wav");

let level = 1;
let blackHole = null;
let gameOver = false;

let blackHoleImg = new Image();
blackHoleImg.src = "fortex.gif";

let crystalImg = new Image();
crystalImg.src = "Crystal.jpg";

let assetsToLoad = [goalImg, blackHoleImg, crystalImg, bubbleSound, breakSound, impactSound, gameOverSound];
let assetsLoaded = 0;

function handleAssetLoad() {
    assetsLoaded++;
    if (assetsLoaded === assetsToLoad.length) {
        document.getElementById("loadingScreen").style.display = "none";
        gameLoop();
    }
}

function loadAssets() {
    goalImg.onload = handleAssetLoad;
    blackHoleImg.onload = handleAssetLoad;
    crystalImg.onload = handleAssetLoad;
    
    // Audio files don't have an onload event, so we'll just count them as loaded immediately for simplicity
    assetsLoaded += 4;
    
    if (assetsLoaded === assetsToLoad.length) {
        document.getElementById("loadingScreen").style.display = "none";
        gameLoop();
    }
}

function spawnObstacles(num = 5) {
    obstacles = [];
    for (let i = 0; i < num; i++) {
        obstacles.push({
            x: Math.random() * (canvas.width - 60) + 30,
            y: Math.random() * (canvas.height - 60) + 30,
            size: Math.random() * 30 + 30,
            color: `hsl(${Math.random() * 360},100%,50%)`,
        });
    }
}
spawnObstacles(8);

function drawBall() {
    ctx.save();
    ctx.translate(ball.x, ball.y);
    ball.shimmerAngle += 0.1;
    const gradient = ctx.createRadialGradient(0, 0, ball.r * 0.3, 0, 0, ball.r);
    gradient.addColorStop(0, `hsl(${(ball.shimmerAngle * 50) % 360}, 100%, 70%)`);
    gradient.addColorStop(1, "#fff");
    ctx.beginPath();
    ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = gradient;
    ctx.shadowBlur = 15;
    ctx.shadowColor = "#4af0f8";
    ctx.fill();
    ctx.restore();
}

function drawGoal() {
    if (goalImg.complete) {
        ctx.drawImage(goalImg, goal.x - goal.size / 2, goal.y - goal.size / 2, goal.size, goal.size);
    } else {
        ctx.beginPath();
        ctx.arc(goal.x, goal.y, goal.size / 2, 0, Math.PI * 2);
        ctx.fillStyle = "#ff4af0";
        ctx.fill();
    }
}

function drawObstacle(o) {
    if (crystalImg.complete) {
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = o.color;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.size / 2, 0, Math.PI * 2);
        ctx.clip();
        ctx.drawImage(crystalImg, o.x - o.size / 2, o.y - o.size / 2, o.size, o.size);
        ctx.restore();
        ctx.shadowBlur = 0;
    }
}

function drawParticles() {
    particles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        p.x += p.vx;
        p.y += p.vy;
        p.alpha -= 0.02;
        if (p.alpha <= 0) particles.splice(i, 1);
    });
}

function splitObstacle(o) {
    breakSound.currentTime = 0;
    breakSound.play();
    for (let i = 0; i < 5; i++) {
        particles.push({
            x: o.x,
            y: o.y,
            size: Math.random() * 5 + 3,
            color: o.color,
            vx: (Math.random() - 0.5) * 4,
            vy: (Math.random() - 0.5) * 4,
            alpha: 1
        });
    }
}

function updateScoreDisplay() {
    document.getElementById("score").innerText = "Earnings: " + scoreTiffy.toFixed(2) + " TIFFY";
}

function gameLoop() {
    if (gameOver) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawGoal();
    obstacles.forEach(o => drawObstacle(o));
    drawParticles();
    drawBall();
    drawBlackHole();

    let multiplier = boostActive ? boostFactor : 1;
    ball.x += speed.x * multiplier;
    ball.y += speed.y * multiplier;

    if (ball.x - ball.r < 0) ball.x = ball.r;
    if (ball.x + ball.r > canvas.width) ball.x = canvas.width - ball.r;
    if (ball.y - ball.r < 0) ball.y = ball.r;
    if (ball.y + ball.r > canvas.height) ball.y = canvas.height - ball.r;

    const dx = ball.x - goal.x;
    const dy = ball.y - goal.y;
    if (Math.sqrt(dx * dx + dy * dy) < ball.r + goal.size / 2) {
        scoreTiffy += tiffyPerPoint;
        localStorage.setItem('tetrusScore', scoreTiffy.toFixed(2));
        updateScoreDisplay();
        bubbleSound.currentTime = 0;
        bubbleSound.play();
        goal.x = Math.random() * (canvas.width - 60) + 30;
        goal.y = Math.random() * (canvas.height - 60) + 30;
        currentTiltSpeed = Math.max(2, currentTiltSpeed - speedIncreasePerCoin);
        level++;
        if (level === 10) {
            blackHole = {
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                radius: 50,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                angle: 0,
                zoomAngle: 0
            };
        }
    }

    obstacles = obstacles.filter(o => {
        let hit = false;
        const dist = Math.sqrt((ball.x - o.x) ** 2 + (ball.y - o.y) ** 2);
        hit = dist < ball.r + o.size / 2;
        
        if (hit && boostActive) {
            splitObstacle(o);
            return false;
        }
        if (hit && !boostActive) {
            const angle = Math.atan2(dy, dx);
            speed.x = -Math.cos(angle) * 5;
            speed.y = -Math.sin(angle) * 5;
            impactSound.currentTime = 0;
            impactSound.play();
        }
        return true;
    });

    if (blackHole) {
        // Update black hole position
        blackHole.x += blackHole.vx;
        blackHole.y += blackHole.vy;

        // Bounce off walls
        if (blackHole.x - blackHole.radius < 0 || blackHole.x + blackHole.radius > canvas.width) {
            blackHole.vx *= -1;
        }
        if (blackHole.y - blackHole.radius < 0 || blackHole.y + blackHole.radius > canvas.height) {
            blackHole.vy *= -1;
        }

        const distToHole = Math.sqrt((ball.x - blackHole.x)**2 + (ball.y - blackHole.y)**2);
        if (distToHole < blackHole.radius + ball.r) {
            gameOver = true;
            gameOverSound.play();
            document.getElementById("gameOverScreen").style.display = "flex";
        } else {
            ball.x += (blackHole.x - ball.x) * 0.005;
            ball.y += (blackHole.y - ball.y) * 0.005;
        }
    }

    requestAnimationFrame(gameLoop);
}

window.addEventListener("deviceorientation", function (event) {
    if (event.gamma !== null && event.beta !== null) {
        speed.x = event.gamma / currentTiltSpeed;
        speed.y = event.beta / currentTiltSpeed;
    }
});

const boostBtn = document.getElementById("accelerator");
boostBtn.addEventListener("touchstart", (e) => {
    e.preventDefault();
    if (isBoostReady) {
        boostActive = true;
        isBoostReady = false;
        boostBtn.classList.add('disabled');
        setTimeout(() => {
            isBoostReady = true;
            boostBtn.classList.remove('disabled');
        }, boostCooldownTime);
    }
});
boostBtn.addEventListener("touchend", () => boostActive = false);
boostBtn.addEventListener("mousedown", () => {
    if (isBoostReady) {
        boostActive = true;
        isBoostReady = false;
        boostBtn.classList.add('disabled');
        setTimeout(() => {
            isBoostReady = true;
            boostBtn.classList.remove('disabled');
        }, boostCooldownTime);
    }
});
boostBtn.addEventListener("mouseup", () => boostActive = false);

document.getElementById("tryAgainBtn").addEventListener("click", () => {
    location.reload();
});

function drawBlackHole() {
    if (!blackHole) return;

    const imgRadius = blackHole.radius * 0.75;
    const scaleFactor = 1 + Math.sin(blackHole.zoomAngle) * 0.1;

    ctx.save();
    // Draw the white glowing circle
    ctx.beginPath();
    ctx.arc(blackHole.x, blackHole.y, blackHole.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#000";
    ctx.shadowBlur = 30;
    ctx.shadowColor = "rgba(255, 255, 255, 0.7)";
    ctx.fill();
    ctx.shadowBlur = 0;

    // Draw the fortex.gif as a round "profile picture" inside
    if (blackHoleImg.complete) {
        ctx.beginPath();
        ctx.arc(blackHole.x, blackHole.y, imgRadius * scaleFactor, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.clip();
        ctx.save();
        ctx.translate(blackHole.x, blackHole.y);
        ctx.rotate(blackHole.angle);
        ctx.drawImage(blackHoleImg, -imgRadius * scaleFactor, -imgRadius * scaleFactor, imgRadius * 2 * scaleFactor, imgRadius * 2 * scaleFactor);
        ctx.restore();
    }
    ctx.restore();

    blackHole.angle += 0.02; // Spinning effect
    blackHole.zoomAngle += 0.05; // Zooming effect
}

loadAssets();
</script>

</body>
</html>
